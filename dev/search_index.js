var documenterSearchIndex = {"docs":
[{"location":"generated/basic_interaction/#","page":"Basic Interaction","title":"Basic Interaction","text":"EditURL = \"https://github.com/Kunz-David/LAP_Julia.jl/blob/master/docs/src/man/examples/basic_interaction.jl\"","category":"page"},{"location":"generated/basic_interaction/#basic_interaction-1","page":"Basic Interaction","title":"Basic Interaction","text":"","category":"section"},{"location":"generated/basic_interaction/#","page":"Basic Interaction","title":"Basic Interaction","text":"(Image: ) (Image: )","category":"page"},{"location":"generated/basic_interaction/#","page":"Basic Interaction","title":"Basic Interaction","text":"In this example page I will show how to work with basic function that are meant for working with this registration algorithms.","category":"page"},{"location":"generated/basic_interaction/#First-how-to-generate-some-images-that-we-can-register-1","page":"Basic Interaction","title":"First how to generate some images that we can register","text":"","category":"section"},{"location":"generated/basic_interaction/#","page":"Basic Interaction","title":"Basic Interaction","text":"We can do this with the gen_init for example.","category":"page"},{"location":"generated/basic_interaction/#","page":"Basic Interaction","title":"Basic Interaction","text":"# using the package\nusing LAP_julia;\n\n# default arguments:\nimg, imgw, flow = gen_init();\n\n# get a chess board image with a uniform flow:\nimg_chess, imgw_chess, flow_uniform = gen_init(:chess, :uniform, flow_args=[1 + 1im]);\nnothing #hide","category":"page"},{"location":"generated/basic_interaction/#","page":"Basic Interaction","title":"Basic Interaction","text":"See also: gen_chess, gen_quad_flow, gen_quad_flow, gen_lena, gen_chess, gen_anhir","category":"page"},{"location":"generated/basic_interaction/#Next-we-would-like-to-display-these-generated-images-and-flows-1","page":"Basic Interaction","title":"Next we would like to display these generated images and flows","text":"","category":"section"},{"location":"generated/basic_interaction/#","page":"Basic Interaction","title":"Basic Interaction","text":"For that we will use the imgshow, showflow and imgoverlay functions.","category":"page"},{"location":"generated/basic_interaction/#","page":"Basic Interaction","title":"Basic Interaction","text":"See a single image:","category":"page"},{"location":"generated/basic_interaction/#","page":"Basic Interaction","title":"Basic Interaction","text":"imgshow(img)","category":"page"},{"location":"generated/basic_interaction/#","page":"Basic Interaction","title":"Basic Interaction","text":"See the default random flow:","category":"page"},{"location":"generated/basic_interaction/#","page":"Basic Interaction","title":"Basic Interaction","text":"showflow(flow)","category":"page"},{"location":"generated/basic_interaction/#","page":"Basic Interaction","title":"Basic Interaction","text":"See the uniform flow:","category":"page"},{"location":"generated/basic_interaction/#","page":"Basic Interaction","title":"Basic Interaction","text":"showflow(flow_uniform)","category":"page"},{"location":"generated/basic_interaction/#","page":"Basic Interaction","title":"Basic Interaction","text":"See the differences between 2 images:","category":"page"},{"location":"generated/basic_interaction/#","page":"Basic Interaction","title":"Basic Interaction","text":"imgoverlay(img, imgw)","category":"page"},{"location":"generated/basic_interaction/#","page":"Basic Interaction","title":"Basic Interaction","text":"See also: imgshowflow, warp_imgshowflow, gen_quad_flow, gen_lena, gen_chess, gen_anhir,","category":"page"},{"location":"generated/basic_interaction/#","page":"Basic Interaction","title":"Basic Interaction","text":"","category":"page"},{"location":"generated/basic_interaction/#","page":"Basic Interaction","title":"Basic Interaction","text":"This page was generated using Literate.jl.","category":"page"},{"location":"generated/registration_functions/#","page":"Registration Functions Showcase","title":"Registration Functions Showcase","text":"EditURL = \"https://github.com/Kunz-David/LAP_Julia.jl/blob/master/docs/src/man/examples/registration_functions.jl\"","category":"page"},{"location":"generated/registration_functions/#Registration-Functions-Showcase-1","page":"Registration Functions Showcase","title":"Registration Functions Showcase","text":"","category":"section"},{"location":"generated/registration_functions/#","page":"Registration Functions Showcase","title":"Registration Functions Showcase","text":"(Image: ) (Image: )","category":"page"},{"location":"generated/registration_functions/#","page":"Registration Functions Showcase","title":"Registration Functions Showcase","text":"In this example page I will show how to work with the registration algorithms lap, pflap, sparse_lap and sparse_pflap.","category":"page"},{"location":"generated/registration_functions/#","page":"Registration Functions Showcase","title":"Registration Functions Showcase","text":"I will generate some images to show the workings and function calls.","category":"page"},{"location":"generated/registration_functions/#","page":"Registration Functions Showcase","title":"Registration Functions Showcase","text":"# using the package\nusing LAP_julia;\n\n# default arguments:\nimg, imgw, flow = gen_init();\nnothing #hide","category":"page"},{"location":"generated/registration_functions/#","page":"Registration Functions Showcase","title":"Registration Functions Showcase","text":"See the Basic Interaction section or the Public Documentation for more advanced input generation","category":"page"},{"location":"generated/registration_functions/#","page":"Registration Functions Showcase","title":"Registration Functions Showcase","text":"These are the differences between the target (img) and source (imgw) images.","category":"page"},{"location":"generated/registration_functions/#","page":"Registration Functions Showcase","title":"Registration Functions Showcase","text":"imgoverlay(img, imgw, figtitle=\"Target vs Source\")","category":"page"},{"location":"generated/registration_functions/#Full-LAP-Methods-1","page":"Registration Functions Showcase","title":"Full LAP Methods","text":"","category":"section"},{"location":"generated/registration_functions/#","page":"Registration Functions Showcase","title":"Registration Functions Showcase","text":"These functions are from the algorithms from the paper Local All-Pass Geometric Deformations.","category":"page"},{"location":"generated/registration_functions/#[lap](@ref)-function-1","page":"Registration Functions Showcase","title":"lap function","text":"","category":"section"},{"location":"generated/registration_functions/#","page":"Registration Functions Showcase","title":"Registration Functions Showcase","text":"# set a filter half size, which is larger than the default max displacement: 10 used in gen_init\nfhs = 15;\nflow_est, source_reg = lap(img, imgw, fhs);\nnothing #hide","category":"page"},{"location":"generated/registration_functions/#","page":"Registration Functions Showcase","title":"Registration Functions Showcase","text":"This gives us a estimation of the flow and the registered source image","category":"page"},{"location":"generated/registration_functions/#","page":"Registration Functions Showcase","title":"Registration Functions Showcase","text":"This is what the registered source image looks like:","category":"page"},{"location":"generated/registration_functions/#","page":"Registration Functions Showcase","title":"Registration Functions Showcase","text":"imgoverlay(img, source_reg, figtitle=\"lap: Target vs Registered Source\")","category":"page"},{"location":"generated/registration_functions/#[pflap](@ref)-function-1","page":"Registration Functions Showcase","title":"pflap function","text":"","category":"section"},{"location":"generated/registration_functions/#","page":"Registration Functions Showcase","title":"Registration Functions Showcase","text":"flow_est, source_reg = pflap(img, imgw);\nnothing #hide","category":"page"},{"location":"generated/registration_functions/#","page":"Registration Functions Showcase","title":"Registration Functions Showcase","text":"This gives us a estimation of the flow and the registered source image","category":"page"},{"location":"generated/registration_functions/#","page":"Registration Functions Showcase","title":"Registration Functions Showcase","text":"This is what the registered source image looks like:","category":"page"},{"location":"generated/registration_functions/#","page":"Registration Functions Showcase","title":"Registration Functions Showcase","text":"imgoverlay(img, source_reg, figtitle=\"pflap: Target vs Registered Source\")","category":"page"},{"location":"generated/registration_functions/#Sparse-LAP-Methods-1","page":"Registration Functions Showcase","title":"Sparse LAP Methods","text":"","category":"section"},{"location":"generated/registration_functions/#","page":"Registration Functions Showcase","title":"Registration Functions Showcase","text":"These functions are insired by the lap and pflap functions. The difference being only some displacement vectors are calculated and the result is fit into a global deformation.","category":"page"},{"location":"generated/registration_functions/#[sparse_lap](@ref)-function-1","page":"Registration Functions Showcase","title":"sparse_lap function","text":"","category":"section"},{"location":"generated/registration_functions/#","page":"Registration Functions Showcase","title":"Registration Functions Showcase","text":"# set a filter half size, which is larger than the default max displacement: 10 used in gen_init\nfhs = 15;\nflow_est, source_reg = lap(img, imgw, fhs);\nnothing #hide","category":"page"},{"location":"generated/registration_functions/#","page":"Registration Functions Showcase","title":"Registration Functions Showcase","text":"This gives us a estimation of the flow and the registered source image","category":"page"},{"location":"generated/registration_functions/#","page":"Registration Functions Showcase","title":"Registration Functions Showcase","text":"This is what the registered source image looks like:","category":"page"},{"location":"generated/registration_functions/#","page":"Registration Functions Showcase","title":"Registration Functions Showcase","text":"imgoverlay(img, source_reg, figtitle=\"lap: Target vs Registered Source\")","category":"page"},{"location":"generated/registration_functions/#[pflap](@ref)-function-2","page":"Registration Functions Showcase","title":"pflap function","text":"","category":"section"},{"location":"generated/registration_functions/#","page":"Registration Functions Showcase","title":"Registration Functions Showcase","text":"flow_est, source_reg = pflap(img, imgw);\nnothing #hide","category":"page"},{"location":"generated/registration_functions/#","page":"Registration Functions Showcase","title":"Registration Functions Showcase","text":"This gives us a estimation of the flow and the registered source image","category":"page"},{"location":"generated/registration_functions/#","page":"Registration Functions Showcase","title":"Registration Functions Showcase","text":"This is what the registered source image looks like:","category":"page"},{"location":"generated/registration_functions/#","page":"Registration Functions Showcase","title":"Registration Functions Showcase","text":"imgoverlay(img, source_reg, figtitle=\"pflap: Target vs Registered Source\")","category":"page"},{"location":"generated/registration_functions/#","page":"Registration Functions Showcase","title":"Registration Functions Showcase","text":"","category":"page"},{"location":"generated/registration_functions/#","page":"Registration Functions Showcase","title":"Registration Functions Showcase","text":"This page was generated using Literate.jl.","category":"page"},{"location":"lib/private/#private_api-1","page":"Internals","title":"Internal Documentation","text":"","category":"section"},{"location":"lib/private/#","page":"Internals","title":"Internals","text":"Documentation for LAP_julia.jl's internal interface.","category":"page"},{"location":"lib/private/#Functions-1","page":"Internals","title":"Functions","text":"","category":"section"},{"location":"lib/private/#","page":"Internals","title":"Internals","text":"Modules = [LAP_julia]\nPublic = false","category":"page"},{"location":"lib/private/#LAP_julia.add_figs_pflap-NTuple{9,Any}","page":"Internals","title":"LAP_julia.add_figs_pflap","text":"add_figs_pflap(figs, level, iter_repeat, u_est, Δ_u, source_reg, level_count, max_repeats)\n\nFill the figs array specifically for the pflap method.\n\n\n\n\n\n","category":"method"},{"location":"lib/private/#LAP_julia.angle_mae-Tuple{Any,Any}","page":"Internals","title":"LAP_julia.angle_mae","text":"function angle_mae(x, y)\n\nCalculate the mean absolute error in angle between x and y. Output in degrees.\n\n\n\n\n\n","category":"method"},{"location":"lib/private/#LAP_julia.angle_rmse-Tuple{Any,Any}","page":"Internals","title":"LAP_julia.angle_rmse","text":"function angle_rmse(x, y)\n\nCalculate the root mean square error in angle between x and y. Output in degrees.\n\n\n\n\n\n","category":"method"},{"location":"lib/private/#LAP_julia.back_substitution3d-Tuple{Any,Any}","page":"Internals","title":"LAP_julia.back_substitution3d","text":"back_substitution3d(A, b)\n\nSolve the linear systems of equations C_n x_n = d_n, where the matrixes C (in row echelon form) are slices from the first 2 dimensions of A, the vectors d are the slices from the first dimension of b and n is the size of the third dimension of A. Returns the coefficients x_n as a 2D matrix coeffs, where the vectors x_n are the rows of this matrix.\n\nSee also: gem3d!, multi_mat_div2\n\n\n\n\n\n","category":"method"},{"location":"lib/private/#LAP_julia.compare_dicts-Tuple{Any,Any}","page":"Internals","title":"LAP_julia.compare_dicts","text":"compare_dicts(old_dict, new_dict)\n\nCompare two dicts by dividing their corresponding values, return the comparation dict.\n\nNote: (old / new)\n\n\n\n\n\n","category":"method"},{"location":"lib/private/#LAP_julia.cumsum2d!-Tuple{Any,Any}","page":"Internals","title":"LAP_julia.cumsum2d!","text":"cumsum2d!(result, A)\n\nCummulative sum over 2D matrix A, storing the result into result.\n\n\n\n\n\n","category":"method"},{"location":"lib/private/#LAP_julia.estimation_noise_variance-Tuple{Array{T,2} where T<:Real}","page":"Internals","title":"LAP_julia.estimation_noise_variance","text":"estimation_noise_variance(img::Image)\n\nEstimate the noise variance of an image y, by evaluating the Median of its Absolute Difference.\n\nNote: Implementation in matlab by Thierry Blu, the Chinese University of Hong kong, Shatin, Hong Kong\n\n\n\n\n\n","category":"method"},{"location":"lib/private/#LAP_julia.fill_circle!-NTuple{4,Any}","page":"Internals","title":"LAP_julia.fill_circle!","text":"fill_circle!(mag, pos, spacing, marker)\n\nFill a circle with a radius of spacing around the point pos into the matrix mag with marker.\n\n\n\n\n\n","category":"method"},{"location":"lib/private/#LAP_julia.filter_border_inds-Tuple{Any,Any,Any}","page":"Internals","title":"LAP_julia.filter_border_inds","text":"filter_border_inds(inds, img_size, border_width)\n\nFilter out the CartesianIndices inds that are within the border_width of an image of size img_size.\n\n\n\n\n\n","category":"method"},{"location":"lib/private/#LAP_julia.fun_on_dict_values-Tuple{Any,Any}","page":"Internals","title":"LAP_julia.fun_on_dict_values","text":"fun_on_dict_values(dicts, fun)\n\nRun function fun on all same keys of all dictionaries dicts.\n\nusing BenchmarkTools\nfun_on_dict_values((Dict(:a => 1), Dict(:a => 12)), mean)\n\n# output\n\nDict{Any,Any} with 1 entry:\n  :a => 6.5\n\n\n\n\n\n\n","category":"method"},{"location":"lib/private/#LAP_julia.gem3d!-Tuple{Any,Any}","page":"Internals","title":"LAP_julia.gem3d!","text":"gem3d!(A, b)\n\nReduce the linear systems of equations C_n x_n = d_n to the row echelon form. The matrixes C are slices from the first 2 dimensions of A, the vectors d are the slices from the first dimension of b and n is the size of the third dimension of A.\n\nSee also: gem3d!, back_substitution3d\n\n\n\n\n\n","category":"method"},{"location":"lib/private/#LAP_julia.gen_one_spaghetti-NTuple{4,Any}","page":"Internals","title":"LAP_julia.gen_one_spaghetti","text":"gen_one_spaghetti(img_size, τ, len, spread)\n\nGenerate a single spaghetti image with the params τ (thickness), len (length) and spread. The coordinates x and y in the equation are scaled from (-1, 1) and the spread gives the length of interval in which the (-1, 1) is randomly located. The genereated spaghetti is also randomly rotated.\n\n(Example for spread 10, the interval for x and y is randomly anywhere between (-9:1) and (-1:9))\n\nThe intensity is equal to:\n\nI(mathrmxy)=left(1-fracf(mathrmx y)τ^2right)left(1+mathrme\n^left(left(mathrmx^2 +mathrmy^2 right) -mathrmlen^2right) left(50 τ^2\nright)right)^-1 mathrme^-f(mathrmx y) left(2 τ^2right)\n\nwhere\n\nf(mathrmx y)=lefty-a x^3-b xright^2 left(1+left3 a x^2-bright^2right)\n\na and b are chosen randomly from a normal distribution.\n\nSee also: gen_spaghetti, spaghetti_fun\n\n\n\n\n\n","category":"method"},{"location":"lib/private/#LAP_julia.gradient_magnitude-Tuple{Any}","page":"Internals","title":"LAP_julia.gradient_magnitude","text":"gradient_magnitude(f)\n\nReturn the directional derivatives (components of the gradient) and the gradient mag for both color and grayscale images. For spatialorder(f)==\"xy\", grad[1] is a derivative wrt x, the first coordinate and grad[2] wrt to the second...\n\n\n\n\n\n","category":"method"},{"location":"lib/private/#LAP_julia.highpass_image-Tuple{Any,Any}","page":"Internals","title":"LAP_julia.highpass_image","text":"highpass_image(img, window_half_size)\n\nHigh-pass img with a hight-pass filter. This high-pass filter is 1-gaussian.\n\n\n\n\n\n","category":"method"},{"location":"lib/private/#LAP_julia.inds_to_points-Tuple{Any}","page":"Internals","title":"LAP_julia.inds_to_points","text":"inds_to_points(inds::Array{CartesianIndex, 1})\n\nTransform an array of CartersianIndexes to an array of where each column is a vector of indices of the input array.\n\n\n\n\n\n","category":"method"},{"location":"lib/private/#LAP_julia.inpaint_nans!-Tuple{Array{Complex{T},2} where T<:Real}","page":"Internals","title":"LAP_julia.inpaint_nans!","text":"inpaint_nans!(flow::Flow)\n\nInpaint NaNs in flow using surrounding non-NaN values.\n\nReferences\n\nOliveira, Manuel & Bowen, Brian & McKenna, Richard & Chang, Yu-Sung. (2001). Fast Digital Image Inpainting.. 261-266. Here.\n\nSee also: showflow, Flow\n\n\n\n\n\n","category":"method"},{"location":"lib/private/#LAP_julia.interpolate_flow_rbf-Union{Tuple{T}, Tuple{Any,Array{CartesianIndex,1},Any}, Tuple{Any,Array{CartesianIndex,1},Any,T}} where T<:ScatteredInterpolation.RadialBasisFunction","page":"Internals","title":"LAP_julia.interpolate_flow_rbf","text":"interpolate_flow_rbf(flow_at_inds,\n                     inds::Array{CartesianIndex, 1},\n                     flow_size,\n                     rbf_method::T=Multiquadratic(2)) where {T <: ScatteredInterpolation.RadialBasisFunction}\n\nInterpolate a complex displacement field of size flow_size from displacement vectors flow_at_inds at inds using the a Multiquadratic RBF model with the parameter ε and using only the values at inds for the interpolation.\n\nExamples of method from ScatteredInterpolation:\n\nMultiquadratic(ɛ = 1)\n\nϕ(r) = sqrt1 + (ɛr)^2\n\nPolyharmonic(k = 1)\n\nϕ(r) = r^k k = 1 3 5 \n\nϕ(r) = r^k ln(r) k = 2 4 6 \n\n(See ScatteredInterpolation for more.)\n\nSee also: showflow, Flow, interpolate_flow, interpolate_flow_quad\n\n\n\n\n\n","category":"method"},{"location":"lib/private/#LAP_julia.mapped_out-Tuple{Array{Complex{T},2} where T<:Real}","page":"Internals","title":"LAP_julia.mapped_out","text":"mapped_out(flow)\n\nReturn a mask that has true at the locations where flow would take the pixel out bounds of the image size.\n\n\n\n\n\n","category":"method"},{"location":"lib/private/#LAP_julia.max_displacement-Tuple{Any}","page":"Internals","title":"LAP_julia.max_displacement","text":"max_displacement(flow)\n\nFind the maximum displacement of flow, ignoring NaNs.\n\n\n\n\n\n","category":"method"},{"location":"lib/private/#LAP_julia.multi_mat_div2-Tuple{Any,Any}","page":"Internals","title":"LAP_julia.multi_mat_div2","text":"multi_mat_div2(A, b)\n\nSolve the linear systems of equations C_n x_n = d_n, where the matrixes C are slices from the first 2 dimensions of A, the vectors d are the slices from the first dimension of b and n is the size of the third dimension of A. Returns the coefficients x_n as a 2D matrix coeffs, where the vectors x_n are the rows of this matrix.\n\nNote: Uses Gaussian elimination and back substitution. Note: For small matrices C, this is an order of magnitude faster than\n\nSee also: gem3d!, back_substitution3d\n\n\n\n\n\n","category":"method"},{"location":"lib/private/#LAP_julia.multi_mat_div_using_qr-Tuple{Any,Any}","page":"Internals","title":"LAP_julia.multi_mat_div_using_qr","text":"multi_mat_div(A, b)\n\nReturn E, where E[i, :] is the solutution of the least squares problem minD_ix - c_i^2 for each D_i and c_i, where D_i is A[:, :, i], c_i is b[:, i] and i is the size of the second dimension of b and third dimension of A. In other words, each row of E is the solution to one matrix from A and it's corresponding vector from b.\n\n\n\n\n\n","category":"method"},{"location":"lib/private/#LAP_julia.normalize_to_zero_one-Tuple{Any}","page":"Internals","title":"LAP_julia.normalize_to_zero_one","text":"normalize_to_zero_one(arr)\n\nNormalize arr so that it has a maximum of 1 and minimum of 0.\n\n\n\n\n\n","category":"method"},{"location":"lib/private/#LAP_julia.pad_images-Tuple{Array{T,2} where T<:Real,Array{T,2} where T<:Real}","page":"Internals","title":"LAP_julia.pad_images","text":"pad_images(image1::Image, image2::Image)\n\nAdds zeros to the right and bottom of image1 and image2 to make them the same size.\n\n\n\n\n\n","category":"method"},{"location":"lib/private/#LAP_julia.prepare_gaussian_filters-Tuple{Any}","page":"Internals","title":"LAP_julia.prepare_gaussian_filters","text":"prepare_gaussian_filters(filter_half_size)\n\nGet KernelFactors for the first 3 forward and backward gaussian filters from the LAP paper.\n\n\n\n\n\n","category":"method"},{"location":"lib/private/#LAP_julia.rescale!-Tuple{Array{T,2} where T<:Real,Array{T,2} where T<:Real}","page":"Internals","title":"LAP_julia.rescale!","text":"rescale!(image1::Image, image2::Image)\n\nRescale image1 and image2 intensities to span the whole [0, 1].\n\n\n\n\n\n","category":"method"},{"location":"lib/private/#LAP_julia.resize_to_diag_size-Tuple{Any,Any}","page":"Internals","title":"LAP_julia.resize_to_diag_size","text":"resize_to_diag_size(img, desired_diag_size)\n\nResize img so that it has desired_diag_size pixels on its diagonal.\n\nSee also: gen_anhir, load_anhir_image_pair\n\n\n\n\n\n","category":"method"},{"location":"lib/private/#LAP_julia.smooth_with_gaussian!-Tuple{Array{#s14,2} where #s14<:Number,Integer}","page":"Internals","title":"LAP_julia.smooth_with_gaussian!","text":"smooth_with_gaussian!(A::Matrix{<:Number}, window_half_size_one_dim::Integer)\n\nClean the Matrix A by smoothing using a square 2D Gaussian filter of size 2 * window_half_size_one_dim + 1 in each dimension.\n\n\n\n\n\n","category":"method"},{"location":"lib/private/#LAP_julia.smooth_with_gaussian!-Tuple{Array{#s34,2} where #s34<:Number,Any}","page":"Internals","title":"LAP_julia.smooth_with_gaussian!","text":"smooth_with_gaussian!(A::Matrix{<:Number}, window_half_size)\n\nSmooth the Matrix A by smoothing using a 2D Gaussian filter of size 2 * window_half_size + 1.\n\n\n\n\n\n","category":"method"},{"location":"lib/private/#LAP_julia.spaghetti_fun-NTuple{6,Any}","page":"Internals","title":"LAP_julia.spaghetti_fun","text":"spaghetti_fun(x, y, a, b, τ, len)\n\nGives the intensity for a single \"spaghetti\" at (x, y) with the params a, b, τ and len.\n\nThe intensity is equal to:\n\nI(mathrmxy)=left(1-fracf(mathrmx y)τ^2right)left(1+mathrme\n^left(left(mathrmx^2 +mathrmy^2 right) -mathrmlen^2right) left(50 τ^2\nright)right)^-1 mathrme^-f(mathrmx y) left(2 τ^2right)\n\nwhere\n\nf(mathrmx y)=lefty-a x^3-b xright^2 left(1+left3 a x^2-bright^2right)\n\nSee also: gen_spaghetti, gen_one_spaghetti, gen_spaghetti\n\n\n\n\n\n","category":"method"},{"location":"lib/private/#LAP_julia.to_lin_index-Tuple{Any,Any}","page":"Internals","title":"LAP_julia.to_lin_index","text":"to_lin_index(cart_ind, size)\n\nGet linear index from CartesianIndex cart_ind of 2D matrix of size size.\n\n\n\n\n\n","category":"method"},{"location":"lib/private/#LAP_julia.vec_len-Tuple{Any}","page":"Internals","title":"LAP_julia.vec_len","text":"function vec_len(x)\n\nCalculate the lenght of vector x. x is a complex number.\n\n\n\n\n\n","category":"method"},{"location":"lib/private/#LAP_julia.window_sum!-NTuple{4,Any}","page":"Internals","title":"LAP_julia.window_sum!","text":"function window_sum!(result, pixels, img_size, window)\n\nGet a sum of values (using a \"symmetric\" padding on the borders) in a window window around each point and saving the sum into result.\n\nNote: Uses a filter algorithm with a 2D ones kernel. Note: For small images (around 256x256) and small filters (window of size 9 and below) is faster than window_sum3!. <- factcheck this again\n\n\n\n\n\n","category":"method"},{"location":"lib/private/#LAP_julia.window_sum3!-NTuple{4,Any}","page":"Internals","title":"LAP_julia.window_sum3!","text":"function window_sum3!(result, pixels, img_size, window)\n\nGet a sum of values (using a \"symmetric\" padding on the borders) in a window window around each point and saving the sum into result.\n\nNote: Uses a cumsum algorithm. Note: For small images (around 256x256) and large filters (window of size 11 and above) is faster than window_sum!. <- factcheck this again\n\n\n\n\n\n","category":"method"},{"location":"lib/private/#LAP_julia.window_sum3_at_inds!-NTuple{5,Any}","page":"Internals","title":"LAP_julia.window_sum3_at_inds!","text":"function window_sum3!(result, pixels, img_size, window, inds)\n\nGet a sum of values (using a \"symmetric\" padding on the borders) in a window window around inds and saving the sum into result.\n\nNote: Uses a cumsum algorithm.\n\n\n\n\n\n","category":"method"},{"location":"man/guide/#Usage-1","page":"Usage","title":"Usage","text":"","category":"section"},{"location":"lib/public/#public_api-1","page":"Public","title":"Public Documentation","text":"","category":"section"},{"location":"lib/public/#","page":"Public","title":"Public","text":"Documentation for LAP_julia.jl's public interface.","category":"page"},{"location":"lib/public/#","page":"Public","title":"Public","text":"See the Internals section of the manual for internal package docs covering all submodules.","category":"page"},{"location":"lib/public/#Index-1","page":"Public","title":"Index","text":"","category":"section"},{"location":"lib/public/#","page":"Public","title":"Public","text":"Pages = [\"public.md\"]","category":"page"},{"location":"lib/public/#Public-Interface-1","page":"Public","title":"Public Interface","text":"","category":"section"},{"location":"lib/public/#Types-1","page":"Public","title":"Types","text":"","category":"section"},{"location":"lib/public/#","page":"Public","title":"Public","text":"Modules = [LAP_julia]\nOrder = [:type]\nPrivate = false","category":"page"},{"location":"lib/public/#LAP_julia.Flow","page":"Public","title":"LAP_julia.Flow","text":"Flow{T} = Matrix{Complex{T}} where T <: Real\n\nFlow is a Matrix with elements that are Complex.\n\n\n\n\n\n","category":"type"},{"location":"lib/public/#LAP_julia.Image","page":"Public","title":"LAP_julia.Image","text":"Image{T} = Matrix{T} where T <: Real\n\nImage is a Matrix with elements that are Real.\n\n\n\n\n\n","category":"type"},{"location":"lib/public/#Functions-1","page":"Public","title":"Functions","text":"","category":"section"},{"location":"lib/public/#","page":"Public","title":"Public","text":"Modules = [LAP_julia]\nOrder = [:function]\nPrivate = false","category":"page"},{"location":"lib/public/#LAP_julia.addpoints-Tuple{Any}","page":"Public","title":"LAP_julia.addpoints","text":"addpoints(inds; ret::Symbol=:figure, labels=[])\n\nAdd points to a plot at the locations inds optionaly provide labels.\n\n\n\n\n\n","category":"method"},{"location":"lib/public/#LAP_julia.assess_flow_quality-Tuple{Any,Any}","page":"Public","title":"LAP_julia.assess_flow_quality","text":"assess_flow_quality(flow, flow_est; title=\"\", display::Bool=true)\n\nRun a few tests on comparing flow_est and flow.\n\nTests: [angle_mae, angle_rmse, mae, mse]\n\n\n\n\n\n","category":"method"},{"location":"lib/public/#LAP_julia.assess_source_reg_quality-Tuple{Any,Any}","page":"Public","title":"LAP_julia.assess_source_reg_quality","text":"assess_source_reg_quality(target, source_reg; title=\"\", display::Bool=true)\n\nRun a few tests on comparing target and source_reg.\n\nTests: [ncc, mae, rmse, mse]\n\n\n\n\n\n","category":"method"},{"location":"lib/public/#LAP_julia.find_edge_points-Tuple{Array{T,2} where T<:Real}","page":"Public","title":"LAP_julia.find_edge_points","text":"find_edge_points(img::Image; spacing::Int=35, point_count::Int=35, sigma=1, mask::BitArray{2}=BitArray{2}(undef, 0,0))\n\nGreadily locate point_count of points in img with the highest gradient magnitude. These points have will be atleast spacing pixels appart, they are returned as an array of CartesianIndex. A mask can be used to exclude some parts of img from the search.\n\nNote: sigma is the gaussian filter used to smooth img before looking for gradients.\n\n\n\n\n\n","category":"method"},{"location":"lib/public/#LAP_julia.gen_anhir","page":"Public","title":"LAP_julia.gen_anhir","text":"gen_anhir(base_path = \"/Users/MrTrololord/Documents/anhir/\";\n          mutate=true,\n          diag_pixels=500)\n\nGenerate a random ANHIR image pair target and source images (in this order) from the ANHIR dataset at base_path.\n\nSee also: load_anhir_image_pair\n\n\n\n\n\n","category":"function"},{"location":"lib/public/#LAP_julia.gen_chess","page":"Public","title":"LAP_julia.gen_chess","text":"gen_chess(tile_size::Integer=50, board_size::Integer=4)\n\nCreate a chessboard image with board_size tiles in each dimension, where each tile is tile_size pixels in each dimension. Note that board_size has to be even.\n\nSee also: imgshow, gen_tiled_flow\n\n\n\n\n\n","category":"function"},{"location":"lib/public/#LAP_julia.gen_init","page":"Public","title":"LAP_julia.gen_init","text":"gen_init(type::Symbol=:lena; flow_args=[])\n\nCreate the usual testing data; img, imgw, flow using the given parameters.\n\nArguments\n\nimg_type::Symbol=:lena: what base image is used. [Options: :lena, :chess]\nflow_type::Symbol=:quad: what flow generation function is used. [Options: :tiled, :quad, :uniform, :spaghetti]\n\nKeyword Arguments\n\nflow_args=[]: arguments passed to the flow generation function besides the flow size.\nimg_args=[]: arguments passed to the img generation function if :chess is chosen.\n\nExample\n\n# chess image, warped chess image, flow with maximal displacement 20 generated by the `gen_quad_flow` function\nimg, imgw, flow = gen_init(:chess, :quad, flow_args=[20])\n\nSee also: [`gen_anhir`](@ref), [`gen_lena`](@ref), [`gen_spaghetti`](@ref), [`gen_tiled_flow`](@ref), [`gen_quad_flow`](@ref), [`gen_uniform_flow`](@ref)\n\n\n\n\n\n","category":"function"},{"location":"lib/public/#LAP_julia.gen_lena-Tuple{}","page":"Public","title":"LAP_julia.gen_lena","text":"gen_lena()\n\nGet a 256x256 grayscale \"lena\" image.\n\n\n\n\n\n","category":"method"},{"location":"lib/public/#LAP_julia.gen_quad_flow","page":"Public","title":"LAP_julia.gen_quad_flow","text":"gen_quad_flow(img_size, max_magnitude=20)\n\nGenerate a smoothly varying locally constant random flow of size img_size and with a maximal displacement of max_magnitude using a quadratic function:\n\nf(z) = a + b*z + c*z^2\n\nwhere:\n\nz = x + y*i x y  (01)\n\nThe constants a, b and c are random numbers from the normal distribution with mean 0 and standard deviation 1.\n\nSee also: showflow, gen_tiled_flow, Flow\n\n\n\n\n\n","category":"function"},{"location":"lib/public/#LAP_julia.gen_spaghetti","page":"Public","title":"LAP_julia.gen_spaghetti","text":"gen_spaghetti(img_size = (200, 200),\n              τ = 0.2,\n              len = 30;\n              count=25,\n              spread=10)\n\nGenerate an image with count spaghetti images with the params τ (thickness), len (length) and spread. The coordinates x and y in the equation are scaled from (-1, 1) and the spread gives the length of interval in which the (-1, 1) is randomly located. The genereated spaghetti is also randomly rotated.\n\n(Example for spread 10, the interval for x and y is randomly anywhere between (-9:1) and (-1:9))\n\nExample\n\n# feature-full spaghetti image\nimg = gen_spaghetti((256, 256), 0.15, 70, spread=20)\n# feature-less spaghetti image\nimg = gen_spaghetti((256, 256), 1, 50, spread=12)\n\nNote: For the exact intensity function see gen_one_spaghetti\n\nSee also:  spaghetti_fun\n\n\n\n\n\n","category":"function"},{"location":"lib/public/#LAP_julia.gen_tiled_flow-Union{Tuple{}, Tuple{Tuple{T,T}}, Tuple{T}, Tuple{Tuple{T,T},Real}, Tuple{Tuple{T,T},Real,Any}, Tuple{Tuple{T,T},Real,Any,Any}} where T<:Integer","page":"Public","title":"LAP_julia.gen_tiled_flow","text":"gen_tiled_flow(flow_size::Tuple{T, T}=(200, 200),\nmax_magnitude::Real=20, tile_size=nothing; filter_amp=nothing)::Flow where {T <: Integer}\n\nGenerate a smoothly varying random flow. The flow parameters are set by the function arguments.\n\nIt works by generating a tiled flow where each tile has a random uniform flow. Then it smooths these tiles by filtering with a gaussian.\n\nArguments\n\nflow_size::Tuple{T, T}=(200, 200): dimensions of the flow.\nmax_magnitude::Real=20: maximum allowed amplitude of the displacement.\ntile_size=nothing: size of random uniform flow tiles that make up the start matrix. (The larger the slower the flow.) Note: If set to flow_size or larger it will generate a uniform pixel shift in a random direction.\nfilter_amp=nothing: size of the gaussian filter which is used to smooth the random start matrix.\n\nSee also: showflow, Flow, gen_chess, gen_quad_flow\n\n\n\n\n\n","category":"method"},{"location":"lib/public/#LAP_julia.gen_uniform_flow","page":"Public","title":"LAP_julia.gen_uniform_flow","text":"gen_uniform_flow(flow_size=(200, 200), vector=1 + 1im, max_magnitude=vec_len(vector))\n\nGenerate a uniform flow of size flow_size, where every displacement vector is vector, scaled by max_magnitude.\n\nNote: max_magnitude = vec_len(vector) by default, so if nothing is enetered as max_magnitude the flow is made up of vector and is not scaled.\n\nSee also: showflow, gen_tiled_flow, Flow, gen_quad_flow\n\n\n\n\n\n","category":"function"},{"location":"lib/public/#LAP_julia.imgoverlay-Tuple{Any,Any}","page":"Public","title":"LAP_julia.imgoverlay","text":"imgoverlay(img1, img2; fig=nothing, figtitle::String=\"Image overlay\", ret::Symbol=:figure)\n\nShow an overlay of the images img1 and img2, each in a different colors, to better see the differences between them.\n\nSee also: imgshow\n\n\n\n\n\n","category":"method"},{"location":"lib/public/#LAP_julia.imgshow-Tuple{Any}","page":"Public","title":"LAP_julia.imgshow","text":"imgshow(img; <keyword arguments>)\n\nReturn a figure with image img. Plot origin is in the botom left.\n\nKeyword Arguments\n\nfig=nothing: add a figure to plot in. By defaults creates a blank new figure.\nfigtitle::String=\"Image\": add title to the figure.\nret::Symbol=:figure: set return object, by default returns Figure, other options: :pyobject returns a PyObject. (Using figure makes Juno directly plot.)\norigin_left_bot::Bool=false: set the origin to the lower left corner, which is not typical for images (they will appear flipped).\n\nSee also: showflow, imgshowflow, warp_imgshowflow\n\n\n\n\n\n","category":"method"},{"location":"lib/public/#LAP_julia.imgshowflow-Tuple{Any,Array{Complex{T},2} where T<:Real}","page":"Public","title":"LAP_julia.imgshowflow","text":"imgshowflow(img, flow; <keyword arguments>)\n\nReturn a figure with an image img and displacement field flow.\n\nKeyword Arguments\n\nimg: the image to be plotted.\nflow::Flow: the vector flow to be plotted.\ndisp_type::Symbol=:full : display mode, either :full -> display all the vectors, or :sparse -> displays only the vectors above a threshold.\nskip_count=nothing: the number of vectors to skip between each displayed vector. By default set so that the output is 20  20 vectors.\nfig=nothing: add a figure to plot in. By defaults creates a blank new figure.\nmag::Real=1: magnify the plotted vectors.\nkey::Bool=true: add key with maximum vector length.\nfigtitle::String=\"Iamge with Flow\": add title to the figure.\nret::Symbol=:figure: set return object, by default returns Figure, other options: :pyobject returns a PyObject. (Using figure makes Juno directly plot.)\norigin_left_bot::Bool=true: set the origin to the lower left corner, which is not typical for images (they will appear flipped).\n\nSee also: imgshow, showflow, warp_imgshowflow\n\n\n\n\n\n","category":"method"},{"location":"lib/public/#LAP_julia.interpolate_flow-Tuple{Any,Array{CartesianIndex,1},Any}","page":"Public","title":"LAP_julia.interpolate_flow","text":"interpolateflow(flowatinds,                  inds::Array{CartesianIndex, 1},                  flowsize;                  method::Symbol=:quad,                  kwargs=Dict())\n\nInterpolate a complex dispalcment field of size flow_size from an array of displacement vectors flow_at_inds, that are at the locations inds. You can choose between two methods method=:quad which fits the displacement vectors into a global quadratic displacement field and method=:rbf which uses an rbf model. Additional keyword arguments of the chosen method can be passed as kwargs.\n\nSee also: Flow, interpolate_flow_quad, interpolate_flow_rbf\n\n\n\n\n\n","category":"method"},{"location":"lib/public/#LAP_julia.interpolate_flow_quad-Tuple{Any,Any,Any}","page":"Public","title":"LAP_julia.interpolate_flow_quad","text":"interpolate_flow_quad(flow_at_inds, inds, flow_size)\n\nInterpolate a complex displacement field of size flow_size from displacement vectors flow_at_inds at inds using a global quadratic model.\n\nThe fit to this model is made by minimizing the following:\n\nmin_a_k sum_x y  mathrmindsleftu_mathrmquad(x y)-u_mathrmflow_at_inds(x y)right^2\n\n,\n\nwhere:\n\nu_mathrmquad(x y) = a_1 + a_2x + a_3y + a_4x^2 + a_5y^2 + a_6xy\n\nSee also: showflow, Flow, interpolate_flow, interpolate_flow_rbf\n\n\n\n\n\n","category":"method"},{"location":"lib/public/#LAP_julia.lap","page":"Public","title":"LAP_julia.lap","text":"lap(args; kwargs)\n\nReturn a 2D Flow matrix of displacements that transforms source closer to target and source image transformed with this displacement field, source_reg.\n\nDetails\n\nPerform the classic Local All-Pass algorithm with post-proccessing (inpainting and smoothing), then warps the source image with the resulting estimate flow.\n\nArguments:\n\ntarget::Image: target/fixed grayscale image.\nsource::Image: source/moving grayscale image.\nfhs::Integer: the half size of the base of the gaussian filters used.\nwindow_size=(2fhs+1, 2fhs+1): the size of the local window (tuple of 2 ints), usually same as filter_size.\n\nKeyword Arguments:\n\ntimer::TimerOutput=TimerOutput(\"lap\"): provide a timer which times certain blocks in the function.\ndisplay::Bool=false: verbose and debug prints.\n\nOutputs:\n\nflow_estim: full estimated flow.\nsource_reg: source image warped by flow_estim.\n\nSee also: single_lap, inpaint_nans!, smooth_with_gaussian!, warp_img.\n\n\n\n\n\n","category":"function"},{"location":"lib/public/#LAP_julia.load_anhir_image_pair-Tuple{Any,Any}","page":"Public","title":"LAP_julia.load_anhir_image_pair","text":"load_anhir_image_pair(target_path,\n                      source_path;\n                      base_path = \"/Users/MrTrololord/Documents/anhir/dataset\")\n\nLoad an image pair in the locations target_path and source_path from the location base_path.\n\nSee also: gen_anhir\n\n\n\n\n\n","category":"method"},{"location":"lib/public/#LAP_julia.mean-Tuple{Any}","page":"Public","title":"LAP_julia.mean","text":"function mean(x)\n\nCalculate the mean of x.\n\n\n\n\n\n","category":"method"},{"location":"lib/public/#LAP_julia.pflap-Tuple{Array{T,2} where T<:Real,Array{T,2} where T<:Real}","page":"Public","title":"LAP_julia.pflap","text":"pflap(args; kwargs)\n\nFind a transformation flow (complex displacment field), that transforms image source to image target. Returns the transformation a Flow and the registered source image.\n\nArguments\n\ntarget::Image: the image we want source to look like.\nsource::Image: warped image we want to transform into target.\n\nKeyword Arguments\n\nfilter_count::Integer=3: the number of basis filters used in single_lap calls (so far only =3 implemented).\nmax_repeats::Integer=1: the maximum number of times an iteration of one filter size can be repeated.\ndisplay::Bool=true: use verbose prints and return an array of figures.\ntimer::TimerOutput=TimerOutput(\"pflap\"): provide a timer which times certain blocks in the function.\nmatch_source_histogram::Bool=true: choose to match the source image histogram to the target image histogram.\nrescale_intensities::Bool=false: choose to rescale! intensities of the images to the whole [0, 1] spectrum.\n\nOutputs\n\nflow::Flow: is the complex vector field that transforms source closer to target.\nsource_reg::Image: is the image source transformed by flow.\n[figs::Matrix{Figure}: is a 2D array of PyPlot Figures which shows the work of the algorithm at each iteration. For each iteration there are 3 Figures in this order: 1) current u_est, 2) newest addition to u_est Δ_u, 3) current source_reg.]\n\nDescribtion\n\nImplements the basic concept of Algorithm 2 from the paper without some features. It uses single_lap iteratively; in each iteration using the transformation estimated by single_lap to warp the source image closer to the target image and then using this warped closer image as the source image in the next iteration, while using progressively smaller filter_half_sizes to estimate even small and faster varying displacements.\n\nNote:\n\nIf display=true is chosen the function will also return an array of figures demonstrating the work of the registration.\n\nSee also: single_lap, imgshow,imgshowflow, warp_imgshowflow, Flow\n\n\n\n\n\n","category":"method"},{"location":"lib/public/#LAP_julia.showflow-Tuple{Array{Complex{T},2} where T<:Real}","page":"Public","title":"LAP_julia.showflow","text":"showflow(flow::Flow; <keyword arguments>)\n\nReturn a figure with the displacement field flow by default skipping some vectors to make it easy to read.\n\nKeyword Arguments\n\nflow::Flow: the vector flow to be plotted.\ndisp_type::Symbol=:full : display mode, either :full -> display all the vectors, or :sparse -> displays only the vectors above a threshold, or :auto which decide for you based on the data.\nskip_count=nothing: the number of vectors to skip between each displayed vector. By default set so that the output is 20  20 vectors.\nfig=nothing: add a figure to plot in. By defaults creates a blank new figure.\nmag::Real=1: magnify the plotted vectors.\nkey::Bool=true: add key with maximum vector length.\nfigtitle::String=\"Flow\": add title to the figure.\nret::Symbol=:figure: set return object, by default returns Figure, other options: :pyobject returns a PyObject. (Using figure makes Juno directly plot.)\n\nSee also: imgshow, imgshowflow, warp_imgshowflow\n\n\n\n\n\n","category":"method"},{"location":"lib/public/#LAP_julia.single_lap","page":"Public","title":"LAP_julia.single_lap","text":"single_lap(target::Image, source::Image, filter_half_size::Integer, window, filter_count::Integer=3)\n\nReturn an estimate of a smoothly varying flow of size of target which is the displacement that transforms source closer to target.\n\nArguments:\n\ntarget::Image: target/fixed grayscale image.\nsource::Image: source/moving grayscale image.\nfilter_half_size: the half size of the base of the gaussian filters used.\nwindow: the size of the local window (list of 2 ints) usually same as filter_size.\nfilter_count::Integer=3: the number of basis filters used (so far only =3 implemented).\n\nKeyword Arguments:\n\ntimer::TimerOutput=TimerOutput(\"LAP\"): provide a timer which times certain blocks in the function.\ndisplay::Bool=false: verbose and debug prints.\n\nSee also: pflap, showflow, warp_imgshowflow, imgshowflow\n\n\n\n\n\n","category":"function"},{"location":"lib/public/#LAP_julia.single_lap_at_points-Tuple{Array{T,2} where T<:Real,Array{T,2} where T<:Real,Integer,Any,Array{CartesianIndex,1}}","page":"Public","title":"LAP_julia.single_lap_at_points","text":"single_lap_at_points(args; kwargs)\n\nReturn a vector of displacements that transforms source closer to target at points inds.\n\nArguments:\n\ntarget::Image: target/fixed grayscale image.\nsource::Image: source/moving grayscale image.\nfilter_half_size::Integer: the half size of the base of the gaussian filters used.\nwindow: the size of the local window (list of 2 ints) usually same as filter_size.\ninds::Array{CartesianIndex{2},1}: where to calculate the flow.\n\nKeyword Arguments:\n\nfilter_count::Integer=3: the number of basis filters used (so far only =3 implemented).\ntimer::TimerOutput=TimerOutput(\"Sparse LAP\"): provide a timer which times certain blocks in the function.\ndisplay::Bool=false: verbose and debug prints.\n\nSee also: pflap, showflow, single_lap, sparse_pflap.\n\n\n\n\n\n","category":"method"},{"location":"lib/public/#LAP_julia.sparse_lap","page":"Public","title":"LAP_julia.sparse_lap","text":"sparse_lap(args; kwargs)\n\nReturn a 2D Flow matrix of displacements that transforms source closer to target.\n\nDetails\n\nUses the Local All-Pass algorithm at indices, inds, of the target image, with a high gradient magnitude, to estimate displacement vectors at these locations. These estimated vectors are then fit into a parametric model (flow_interpolation_method) and a full displacemnt field/flow, or full_flow_estim, is made. This flow is then used to warp the source image, creating the source_reg image.\n\nArguments:\n\ntarget::Image: target/fixed grayscale image.\nsource::Image: source/moving grayscale image.\nfhs::Integer: the half size of the base of the gaussian filters used.\nwindow_size=(2fhs+1, 2fhs+1): the size of the local window (tuple of 2 ints), usually same as filter_size.\n\nKeyword Arguments:\n\nspacing::Integer=25: the smallest number of pixels that can separate two inds. See also: find_edge_points\npoint_count::Integer=100: the number of inds we are looking for.\n\n(The method will use the maximum amount up to this number if the this amount of inds isn't found.) See also: find_edge_points\n\ntimer::TimerOutput=TimerOutput(\"sparse_lap\"): provide a timer which times certain blocks in the function.\ndisplay::Bool=false: verbose and debug prints.\nflow_interpolation_method::Symbol=:quad: choose which strategy to use for sparse flow interpolation.\n\n(Choices: :quad -> fits to a global quadratic model, :rbf -> fits to a local rbf model.) See also: interpolate_flow\n\nbase_method_kwargs=Dict(:timer => timer, :display => display)): keyword arguments passed to the base method.\n\n(In this case: single_lap_at_points).\n\nOutputs:\n\nfull_flow_estim: full estimated flow.\nsource_reg: source image warped by full_flow_estim. See also: warp_img.\nflow_estim_at_inds: estimated displacement vectors, at the indices inds. These are fitted into the flow_interpolation_method to\n\nmake the full estimated flow full_flow_estim.\n\ninds: indices chosen for the high gradient at which the flow_estim_at_inds is estimated.\n\nSee also: showflow, imgshow, find_edge_points, interpolate_flow\n\n\n\n\n\n","category":"function"},{"location":"lib/public/#LAP_julia.sparse_pflap-Tuple{Array{T,2} where T<:Real,Array{T,2} where T<:Real}","page":"Public","title":"LAP_julia.sparse_pflap","text":"sparse_pflap(args; kwargs)\n\nFind a transformation flow (complex displacment field), that transforms image source to closer to image target. Returns the transformation a Flow and the registered source image.\n\nArguments:\n\ntarget::Image: target/fixed grayscale image.\nsource::Image: source/moving grayscale image.\n\nKeyword Arguments:\n\nfilter_count::Integer=3: the number of basis filters used (so far only =3 implemented).\ntimer::TimerOutput=TimerOutput(\"sparse pflap\"): provide a timer which times certain blocks in the function.\ndisplay::Bool=false: verbose and debug prints.\npoint_count::Int=500: the number of points attempted to be found at the edges of the target image.\nspacing::Int=10: the minimal distance between two points.\nmatch_source_histogram::Bool=true: choose to match the source image histogram to the target image histogram.\n\nNote:\n\nIf display=true is chosen the function will also return an array of figures demonstrating the work of the registration.\n\nSee also: sparse_lap, pflap, showflow, single_lap, sparse_pflap.\n\n\n\n\n\n","category":"method"},{"location":"lib/public/#LAP_julia.sparse_pflap_psnr-Tuple{Array{T,2} where T<:Real,Array{T,2} where T<:Real}","page":"Public","title":"LAP_julia.sparse_pflap_psnr","text":"sparse_pflap(args; kwargs)\n\nFind a transformation flow (complex displacment field), that transforms image source to closer to image target. Returns the transformation a Flow and the registered source image.\n\nArguments:\n\ntarget::Image: target/fixed grayscale image.\nsource::Image: source/moving grayscale image.\n\nKeyword Arguments:\n\nfilter_count::Integer=3: the number of basis filters used (so far only =3 implemented).\ntimer::TimerOutput=TimerOutput(\"sparse pflap\"): provide a timer which times certain blocks in the function.\ndisplay::Bool=false: verbose and debug prints.\npoint_count::Int=500: the number of points attempted to be found at the edges of the target image.\nspacing::Int=10: the minimal distance between two points.\nmatch_source_histogram::Bool=true: choose to match the source image histogram to the target image histogram.\n\nNote:\n\nIf display=true is chosen the function will also return an array of figures demonstrating the work of the registration.\n\nSee also: sparse_lap, pflap, showflow, single_lap, sparse_pflap.\n\n\n\n\n\n","category":"method"},{"location":"lib/public/#LAP_julia.test_registration_alg-Tuple{Any,Array{T,2} where T<:Real,Array{T,2} where T<:Real,Array{Complex{T},2} where T<:Real}","page":"Public","title":"LAP_julia.test_registration_alg","text":"test_registration_alg(args; kwargs)\n\nTest a registration function method by timing it and comparing its outputs to the ground truth flow and the target image.\n\nArguments:\n\nmethod: registration function.\ntarget::Image: target image.\nsource::Image: source image to be warped closer to target.\nflow::Flow: truth displacement flow warping target to source.\n\nKeyword Arguments:\n\ndisplay::Bool=true: print debugging info and test results.\ntimer::TimerOutput=TimerOutput(\"blank\"): timer to for certain blocks of code in the method.\nmethod_args=[]: arguments for the registration function.\nmethod_kwargs::Dict=Dict(): keyword arguments for the registration function.\n\nOutputs:\n\nflow_est: estimated transformation flow.\nsource_reg: source image registered.\ntimer: timings of the method insides.\nresults: Dict with results of the quality of the registration.\n[(outputs)]: other outputs of the method besides flow_est and source_reg.\n\nExample\n\n# generate a lena image, a warped lena image and a random quadratic flow\nimg, imgw, flow = gen_init();\n# setup timer\ntimer=TimerOutput(\"sparse pf lap\");\n# choose method params\nmethod_kwargs = Dict(:timer => timer, :display => false, :max_repeats => 1, :point_count => 500, :spacing => 10)\n# run and test `sparse_pflap`\nflow_est, source_reg, timer, results = test_registration_alg(sparse_pflap, img, imgw, flow, [], method_kwargs, timer=timer)\n\nSee also: lap, sparse_lap,pflap, sparse_pflap, Flow, time_reg_alg\n\n\n\n\n\n","category":"method"},{"location":"lib/public/#LAP_julia.time_reg_alg-Tuple{Any,Array{T,2} where T<:Real,Array{T,2} where T<:Real}","page":"Public","title":"LAP_julia.time_reg_alg","text":"time_reg_alg(args; kwargs)\n\nRun a registration method and get the time of execution and method outputs.\n\nArguments:\n\nmethod: registration function.\ntarget::Image: target image.\nsource::Image: source image to be warped closer to target.\n\nKeyword Arguments:\n\nmethod_args=[]: arguments for the registration function.\ndisplay::Bool=true: print debugging info and test results.\ntimer::TimerOutput=TimerOutput(\"blank\"): timer to for certain blocks of code in the method.\nmethod_kwargs::Dict=Dict(:timer => timer, :display => display): keyword arguments for the registration function.\n\nOutputs:\n\nflow_est: estimated transformation flow.\nsource_reg: source image registered.\ntimer: timings of the method insides.\ntime_in_secs: execution time of the method in seconds.\n[(outputs)]: other outputs of the method besides flow_est and source_reg.\n\nSee also: test_registration_alg\n\n\n\n\n\n","category":"method"},{"location":"lib/public/#LAP_julia.warp_img-Tuple{Array{T,2} where T<:Real,Any,Any}","page":"Public","title":"LAP_julia.warp_img","text":"warp_img(img::Image, dx, dy; border_strat::Symbol=:replicate)::Image\nwarp_img(img::Image, dx, dy, filling_img::Image)::Image\n\nWarp the image img by dx in x direction and by dy in y direction. border_strat indicates how to act when the resulting coordinate outside of bounds of img.\n\nPossible variations:\n\nborder_strat == :replicate: fill with the closest pixel value.\nborder_strat == :zeros: fill with zeros.\nsupply a filling_img as 3rd argument: fill with the provided image filling_img\n\nSee also: showflow, imgshowflow, Flow\n\n\n\n\n\n","category":"method"},{"location":"lib/public/#LAP_julia.warp_imgshowflow-Tuple{Any,Array{Complex{T},2} where T<:Real}","page":"Public","title":"LAP_julia.warp_imgshowflow","text":"warp_imgshowflow(img, flow; <keyword arguments>)\n\nReturn a figure with an image and a displacement field, where the image is warped by the displacement field.\n\nKeyword Arguments\n\nimg: the image to be plotted.\nflow::Flow: the vector flow to be plotted.\ndisp_type::Symbol=:full : display mode, either :full -> display all the vectors, or :sparse -> displays only the vectors above a threshold.\nskip_count=nothing: the number of vectors to skip between each displayed vector. By default set so that the output is 20  20 vectors.\nfig=nothing: add a figure to plot in. By defaults creates a blank new figure.\nmag::Real=1: magnify the plotted vectors.\nkey::Bool=true: add key with maximum vector length.\nfigtitle::String=\"Iamge with Flow\": add title to the figure.\nret::Symbol=:figure: set return object, by default returns Figure, other options: :pyobject returns a PyObject. (Using figure makes Juno directly plot.)\norigin_left_bot::Bool=true: set the origin to the lower left corner, which is not typical for images (they will appear flipped).\n\nSee also: imgshow, showflow, imgshowflow\n\n\n\n\n\n","category":"method"},{"location":"#LAP_julia.jl-1","page":"LAP_julia.jl","title":"LAP_julia.jl","text":"","category":"section"},{"location":"#","page":"LAP_julia.jl","title":"LAP_julia.jl","text":"Image registration in Julia","category":"page"},{"location":"#Installation-1","page":"LAP_julia.jl","title":"Installation","text":"","category":"section"},{"location":"#","page":"LAP_julia.jl","title":"LAP_julia.jl","text":"To install paste this into a Julia terminal:","category":"page"},{"location":"#","page":"LAP_julia.jl","title":"LAP_julia.jl","text":"using Pkg; Pkg.add(PackageSpec(url=\"https://github.com/Kunz-David/LAP_julia\"))","category":"page"},{"location":"#","page":"LAP_julia.jl","title":"LAP_julia.jl","text":"note: Linux\nThe plotting functions use Julia's PyPlot module and Matplotlib has to be installed in your default Python. You can either install Matplotlib in your Python or let Julia use the Python it installed and manages. For that set ENV[PYTHON] to the Python installed by Julia. So something like this, will do the trick:ENV[\"PYTHON\"] = \"..ENTER USER.../.julia/conda/3/bin\"","category":"page"},{"location":"#Manual-Outline-1","page":"LAP_julia.jl","title":"Manual Outline","text":"","category":"section"},{"location":"#","page":"LAP_julia.jl","title":"LAP_julia.jl","text":"Pages = [\n    \"man/guide.md\",\n    \"man/examples.md\",\n    \"man/syntax.md\",\n    \"man/doctests.md\",\n    \"man/hosting.md\",\n    \"man/latex.md\",\n    \"man/contributing.md\",\n]\nDepth = 1","category":"page"},{"location":"#Library-Outline-1","page":"LAP_julia.jl","title":"Library Outline","text":"","category":"section"},{"location":"#","page":"LAP_julia.jl","title":"LAP_julia.jl","text":"Pages = [\"lib/public.md\", \"lib/private.md\"]","category":"page"},{"location":"man/examples/examples/#OLD-Examples-1","page":"OLD Examples","title":"OLD Examples","text":"","category":"section"},{"location":"man/examples/examples/#","page":"OLD Examples","title":"OLD Examples","text":"Please check out the new examples","category":"page"},{"location":"man/examples/examples/#","page":"OLD Examples","title":"OLD Examples","text":"pages = [\"examples.md\"]\nDepth = 3","category":"page"},{"location":"man/examples/examples/#","page":"OLD Examples","title":"OLD Examples","text":"Here I will show how the basic methods work on different kinds of displacements. I use the word displacement and flow interchangeably.","category":"page"},{"location":"man/examples/examples/#Generate-test-flows-1","page":"OLD Examples","title":"Generate test flows","text":"","category":"section"},{"location":"man/examples/examples/#Unifrom-1","page":"OLD Examples","title":"Unifrom","text":"","category":"section"},{"location":"man/examples/examples/#","page":"OLD Examples","title":"OLD Examples","text":"using LAP_julia # hide\nusing PyPlot\n# Set some parameters:\nex_size = (256, 256)\nex_max_magnitude = 20\nex_tile_size = 999 # This makes the flow uniform\n\n# Generate a random uniform flow\nuni_flow = gen_tiled_flow(ex_size, ex_max_magnitude, ex_tile_size);\n\n# Lets check what the flow looks like:\nshowflow(uni_flow, figtitle=\"Uniform warp\")","category":"page"},{"location":"man/examples/examples/#","page":"OLD Examples","title":"OLD Examples","text":"Check out the used functions: gen_tiled_flow, showflow","category":"page"},{"location":"man/examples/examples/#Non-uniform-Smooth-1","page":"OLD Examples","title":"Non-uniform Smooth","text":"","category":"section"},{"location":"man/examples/examples/#","page":"OLD Examples","title":"OLD Examples","text":"using LAP_julia # hide\nusing PyPlot\n# Set some parameters:\nex_size = (256, 256)\nex_max_magnitude = 20\nex_tile_size = 60\n\n# Generate a random uniform flow\nsmooth_flow = gen_tiled_flow(ex_size, ex_max_magnitude, ex_tile_size);\n\n# Lets check what the flow looks like:\nshowflow(smooth_flow, figtitle=\"Smooth warp\")","category":"page"},{"location":"man/examples/examples/#","page":"OLD Examples","title":"OLD Examples","text":"Check out the used functions: gen_tiled_flow, showflow","category":"page"},{"location":"man/examples/examples/#Generate-test-images-1","page":"OLD Examples","title":"Generate test images","text":"","category":"section"},{"location":"man/examples/examples/#Chessboard-1","page":"OLD Examples","title":"Chessboard","text":"","category":"section"},{"location":"man/examples/examples/#","page":"OLD Examples","title":"OLD Examples","text":"Normal","category":"page"},{"location":"man/examples/examples/#","page":"OLD Examples","title":"OLD Examples","text":"chess = gen_chess(64, 4)\nimgshow(chess, figtitle=\"Chessboard\")","category":"page"},{"location":"man/examples/examples/#","page":"OLD Examples","title":"OLD Examples","text":"Check out the used functions: gen_chess","category":"page"},{"location":"man/examples/examples/#","page":"OLD Examples","title":"OLD Examples","text":"chess = gen_chess(64, 4)","category":"page"},{"location":"man/examples/examples/#","page":"OLD Examples","title":"OLD Examples","text":"Warped with uni_flow","category":"page"},{"location":"man/examples/examples/#","page":"OLD Examples","title":"OLD Examples","text":"chess_uni_warped = warp_img(chess, -real(uni_flow), -imag(uni_flow))\nimgshowflow(chess_uni_warped, uni_flow, figtitle=\"Chessboard uniform warp\")","category":"page"},{"location":"man/examples/examples/#","page":"OLD Examples","title":"OLD Examples","text":"Warped with smooth_flow","category":"page"},{"location":"man/examples/examples/#","page":"OLD Examples","title":"OLD Examples","text":"chess_smooth_warped = warp_img(chess, -real(smooth_flow), -imag(smooth_flow))\nimgshowflow(chess_smooth_warped, smooth_flow, figtitle=\"Chessboard smooth warp\")","category":"page"},{"location":"man/examples/examples/#","page":"OLD Examples","title":"OLD Examples","text":"Check out the used functions: warp_img, imgshowflow","category":"page"},{"location":"man/examples/examples/#Lena-1","page":"OLD Examples","title":"Lena","text":"","category":"section"},{"location":"man/examples/examples/#","page":"OLD Examples","title":"OLD Examples","text":"Normal","category":"page"},{"location":"man/examples/examples/#","page":"OLD Examples","title":"OLD Examples","text":"using TestImages\nlena = testimage(\"lena_gray\")\n# The Lena image from TestImages has elements of type ColorTypes.Gray{FixedPointNumbers.Normed{UInt8,8}}\n# so to use our algorithms later we need to convert them to floats.\nlena = Float32.(lena)\n\nimgshow(lena, figtitle=\"Lena\")","category":"page"},{"location":"man/examples/examples/#","page":"OLD Examples","title":"OLD Examples","text":"using TestImages\nlena = testimage(\"lena_gray\")\n\n# The Lena image from TestImages has elements of type ColorTypes.Gray{FixedPointNumbers.Normed{UInt8,8}} so we convert it to Float32.\nlena = Float32.(lena)","category":"page"},{"location":"man/examples/examples/#","page":"OLD Examples","title":"OLD Examples","text":"Warped with uni_flow","category":"page"},{"location":"man/examples/examples/#","page":"OLD Examples","title":"OLD Examples","text":"lena_uni_warped = warp_img(lena, -real(uni_flow), -imag(uni_flow))\nimgshowflow(lena_uni_warped, uni_flow, figtitle=\"Lena uniform warp\")","category":"page"},{"location":"man/examples/examples/#","page":"OLD Examples","title":"OLD Examples","text":"Warped with smooth_flow","category":"page"},{"location":"man/examples/examples/#","page":"OLD Examples","title":"OLD Examples","text":"lena_smooth_warped = warp_img(lena, -real(smooth_flow), -imag(smooth_flow))\nimgshowflow(lena_smooth_warped, smooth_flow, figtitle=\"Lena smooth warp\")","category":"page"},{"location":"man/examples/examples/#","page":"OLD Examples","title":"OLD Examples","text":"Check out the used functions: warp_img, imgshowflow","category":"page"},{"location":"man/examples/examples/#","page":"OLD Examples","title":"OLD Examples","text":"","category":"page"},{"location":"man/examples/examples/#single_lap-function-1","page":"OLD Examples","title":"single_lap function","text":"","category":"section"},{"location":"man/examples/examples/#","page":"OLD Examples","title":"OLD Examples","text":"Here are examples of using the single_lap function to find the flow between the original and the warped image. I will show the results of the algorithm for an image warped by a uniform flow and a smoothly varying flow. (The code running is the same.)","category":"page"},{"location":"man/examples/examples/#Uniform-Flow-1","page":"OLD Examples","title":"Uniform Flow","text":"","category":"section"},{"location":"man/examples/examples/#","page":"OLD Examples","title":"OLD Examples","text":"This how the algorithm performs on a uniform flow. First we have to choose a filter_half_size which has to be the same or higher that the ex_max_magnitude chosen. Then we choose the window_size parameter of the algorithm, usually a list like this: [2*filter_half_size + 1, 2*filter_half_size + 1].","category":"page"},{"location":"man/examples/examples/#","page":"OLD Examples","title":"OLD Examples","text":"# save original\nshowflow(uni_flow, figtitle=\"Original Uniform Flow\")\nsavefig(\"orig_uni_flow.png\")","category":"page"},{"location":"man/examples/examples/#Chessboard-2","page":"OLD Examples","title":"Chessboard","text":"","category":"section"},{"location":"man/examples/examples/#","page":"OLD Examples","title":"OLD Examples","text":"Run:","category":"page"},{"location":"man/examples/examples/#","page":"OLD Examples","title":"OLD Examples","text":"filter_half_size = 20\nwindow_size = [2*filter_half_size + 1, 2*filter_half_size + 1]\n\nestim_flow = single_lap(chess, chess_uni_warped, filter_half_size, window_size)\nnothing # hide","category":"page"},{"location":"man/examples/examples/#","page":"OLD Examples","title":"OLD Examples","text":"Check out single_lap.","category":"page"},{"location":"man/examples/examples/#","page":"OLD Examples","title":"OLD Examples","text":"Check the results:","category":"page"},{"location":"man/examples/examples/#","page":"OLD Examples","title":"OLD Examples","text":"# save estimation\nshowflow(estim_flow, figtitle=\"Single Estimated Uniform Flow\")\nsavefig(\"single_chess_estim_uni_flow.png\")\nnothing # hide","category":"page"},{"location":"man/examples/examples/#","page":"OLD Examples","title":"OLD Examples","text":"Original Estimated\n(Image: ) (Image: )","category":"page"},{"location":"man/examples/examples/#Lena-2","page":"OLD Examples","title":"Lena","text":"","category":"section"},{"location":"man/examples/examples/#","page":"OLD Examples","title":"OLD Examples","text":"Run:","category":"page"},{"location":"man/examples/examples/#","page":"OLD Examples","title":"OLD Examples","text":"filter_half_size = 20\nwindow_size = [2*filter_half_size + 1, 2*filter_half_size + 1]\n\nestim_flow = single_lap(lena, lena_uni_warped, filter_half_size, window_size)\nnothing # hide","category":"page"},{"location":"man/examples/examples/#","page":"OLD Examples","title":"OLD Examples","text":"Check out single_lap.","category":"page"},{"location":"man/examples/examples/#","page":"OLD Examples","title":"OLD Examples","text":"Check the results:","category":"page"},{"location":"man/examples/examples/#","page":"OLD Examples","title":"OLD Examples","text":"# save estimation\nshowflow(estim_flow, figtitle=\"Single Estimated Uniform Flow\")\nsavefig(\"single_lena_estim_uni_flow.png\")\nnothing # hide","category":"page"},{"location":"man/examples/examples/#","page":"OLD Examples","title":"OLD Examples","text":"Original Estimated\n(Image: ) (Image: )","category":"page"},{"location":"man/examples/examples/#Non-uniform-Smooth-Flow-1","page":"OLD Examples","title":"Non-uniform Smooth Flow","text":"","category":"section"},{"location":"man/examples/examples/#","page":"OLD Examples","title":"OLD Examples","text":"This how the algorithm performs on a non-uniform smoothly varying flow.","category":"page"},{"location":"man/examples/examples/#","page":"OLD Examples","title":"OLD Examples","text":"# save original\nshowflow(smooth_flow, figtitle=\"Original smooth flow\")\nsavefig(\"orig_smooth_flow.png\")","category":"page"},{"location":"man/examples/examples/#Chessboard-3","page":"OLD Examples","title":"Chessboard","text":"","category":"section"},{"location":"man/examples/examples/#","page":"OLD Examples","title":"OLD Examples","text":"Run:","category":"page"},{"location":"man/examples/examples/#","page":"OLD Examples","title":"OLD Examples","text":"filter_half_size = 20\nwindow_size = [2*filter_half_size + 1, 2*filter_half_size + 1]\n\nestim_flow = single_lap(chess, chess_smooth_warped, filter_half_size, window_size)\nnothing # hide","category":"page"},{"location":"man/examples/examples/#","page":"OLD Examples","title":"OLD Examples","text":"Check the results:","category":"page"},{"location":"man/examples/examples/#","page":"OLD Examples","title":"OLD Examples","text":"# save estimation\nshowflow(estim_flow, figtitle=\"Single Estimated Smooth Flow\")\nsavefig(\"single_chess_estim_smooth_flow.png\")\nnothing # hide","category":"page"},{"location":"man/examples/examples/#","page":"OLD Examples","title":"OLD Examples","text":"Original Estimated\n(Image: ) (Image: )","category":"page"},{"location":"man/examples/examples/#Lena-3","page":"OLD Examples","title":"Lena","text":"","category":"section"},{"location":"man/examples/examples/#","page":"OLD Examples","title":"OLD Examples","text":"Run:","category":"page"},{"location":"man/examples/examples/#","page":"OLD Examples","title":"OLD Examples","text":"filter_half_size = 20\nwindow_size = [2*filter_half_size + 1, 2*filter_half_size + 1]\n\nestim_flow = single_lap(lena, lena_smooth_warped, filter_half_size, window_size)\nnothing # hide","category":"page"},{"location":"man/examples/examples/#","page":"OLD Examples","title":"OLD Examples","text":"Check the results:","category":"page"},{"location":"man/examples/examples/#","page":"OLD Examples","title":"OLD Examples","text":"# save estimation\nshowflow(estim_flow, figtitle=\"Single Estimated Smooth Flow\")\nsavefig(\"single_lena_estim_smooth_flow.png\")\nnothing # hide","category":"page"},{"location":"man/examples/examples/#","page":"OLD Examples","title":"OLD Examples","text":"Original Estimated\n(Image: ) (Image: )","category":"page"},{"location":"man/examples/examples/#","page":"OLD Examples","title":"OLD Examples","text":"","category":"page"},{"location":"man/examples/examples/#pflap-function-1","page":"OLD Examples","title":"pflap function","text":"","category":"section"},{"location":"man/examples/examples/#","page":"OLD Examples","title":"OLD Examples","text":"Here are examples of using the pflap function to find the flow between the original and the warped image. I will show the results of the algorithm for an image warped by a uniform flow and a smoothly varying flow. (The code running is the same.)","category":"page"},{"location":"man/examples/examples/#Uniform-Flow-2","page":"OLD Examples","title":"Uniform Flow","text":"","category":"section"},{"location":"man/examples/examples/#","page":"OLD Examples","title":"OLD Examples","text":"This how the algorithm performs on a uniform flow.","category":"page"},{"location":"man/examples/examples/#Chessboard-4","page":"OLD Examples","title":"Chessboard","text":"","category":"section"},{"location":"man/examples/examples/#","page":"OLD Examples","title":"OLD Examples","text":"Run:","category":"page"},{"location":"man/examples/examples/#","page":"OLD Examples","title":"OLD Examples","text":"filter_half_size = 20\nwindow_size = [2*filter_half_size + 1, 2*filter_half_size + 1]\n\nestim_flow, source_reg = pflap(chess, chess_uni_warped, display=false)\nnothing # hide","category":"page"},{"location":"man/examples/examples/#","page":"OLD Examples","title":"OLD Examples","text":"Check out pflap.","category":"page"},{"location":"man/examples/examples/#","page":"OLD Examples","title":"OLD Examples","text":"Check the results:","category":"page"},{"location":"man/examples/examples/#","page":"OLD Examples","title":"OLD Examples","text":"# save estimation\nshowflow(estim_flow, figtitle=\"Polyfilter Estimated Uniform Flow\")\nsavefig(\"polyfilter_chess_estim_uni_flow.png\")\nnothing # hide","category":"page"},{"location":"man/examples/examples/#","page":"OLD Examples","title":"OLD Examples","text":"Original Estimated\n(Image: ) (Image: )","category":"page"},{"location":"man/examples/examples/#Lena-4","page":"OLD Examples","title":"Lena","text":"","category":"section"},{"location":"man/examples/examples/#","page":"OLD Examples","title":"OLD Examples","text":"Run:","category":"page"},{"location":"man/examples/examples/#","page":"OLD Examples","title":"OLD Examples","text":"filter_half_size = 20\nwindow_size = [2*filter_half_size + 1, 2*filter_half_size + 1]\n\nestim_flow, source_reg = pflap(lena, lena_uni_warped, display=false)\nnothing # hide","category":"page"},{"location":"man/examples/examples/#","page":"OLD Examples","title":"OLD Examples","text":"Check out pflap.","category":"page"},{"location":"man/examples/examples/#","page":"OLD Examples","title":"OLD Examples","text":"Check the results:","category":"page"},{"location":"man/examples/examples/#","page":"OLD Examples","title":"OLD Examples","text":"# save estimation\nshowflow(estim_flow, figtitle=\"Polyfilter Estimated Uniform Flow\")\nsavefig(\"polyfilter_lena_estim_uni_flow.png\")\nnothing # hide","category":"page"},{"location":"man/examples/examples/#","page":"OLD Examples","title":"OLD Examples","text":"Original Estimated\n(Image: ) (Image: )","category":"page"},{"location":"man/examples/examples/#Non-uniform-Smooth-2","page":"OLD Examples","title":"Non-uniform Smooth","text":"","category":"section"},{"location":"man/examples/examples/#","page":"OLD Examples","title":"OLD Examples","text":"This how the algorithm performs on a non-uniform smooth flow.","category":"page"},{"location":"man/examples/examples/#Chessboard-5","page":"OLD Examples","title":"Chessboard","text":"","category":"section"},{"location":"man/examples/examples/#","page":"OLD Examples","title":"OLD Examples","text":"Run:","category":"page"},{"location":"man/examples/examples/#","page":"OLD Examples","title":"OLD Examples","text":"estim_flow, source_reg = pflap(chess, chess_smooth_warped, display=false)\nnothing # hide","category":"page"},{"location":"man/examples/examples/#","page":"OLD Examples","title":"OLD Examples","text":"Check the results:","category":"page"},{"location":"man/examples/examples/#","page":"OLD Examples","title":"OLD Examples","text":"# save estimation\nshowflow(estim_flow, figtitle=\"Polyfilter Estimated Smooth Flow\")\nsavefig(\"polyfilter_chess_estim_smooth_flow.png\")\nnothing # hide","category":"page"},{"location":"man/examples/examples/#","page":"OLD Examples","title":"OLD Examples","text":"Original Estimated\n(Image: ) (Image: )","category":"page"},{"location":"man/examples/examples/#Lena-5","page":"OLD Examples","title":"Lena","text":"","category":"section"},{"location":"man/examples/examples/#","page":"OLD Examples","title":"OLD Examples","text":"Run:","category":"page"},{"location":"man/examples/examples/#","page":"OLD Examples","title":"OLD Examples","text":"filter_half_size = 20\nwindow_size = [2*filter_half_size + 1, 2*filter_half_size + 1]\n\nestim_flow, source_reg = pflap(lena, lena_smooth_warped, display=false)\nnothing # hide","category":"page"},{"location":"man/examples/examples/#","page":"OLD Examples","title":"OLD Examples","text":"Check the results:","category":"page"},{"location":"man/examples/examples/#","page":"OLD Examples","title":"OLD Examples","text":"# save estimation\nshowflow(estim_flow, figtitle=\"Polyfilter Estimated Smooth Flow\")\nsavefig(\"polyfilter_lena_estim_smooth_flow.png\")\nnothing # hide","category":"page"},{"location":"man/examples/examples/#","page":"OLD Examples","title":"OLD Examples","text":"Original Estimated\n(Image: ) (Image: )","category":"page"}]
}
